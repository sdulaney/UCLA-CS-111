Total: 2566 samples
    2536  98.8%  98.8%     2565 100.0% thread_start_routine
      23   0.9%  99.7%       28   1.1% SortedList_lookup
       2   0.1%  99.8%        2   0.1% ?? /usr/src/debug////////glibc-2.17-c758a686/string/../sysdeps/x86_64/multiarch/strcmp-sse42.S:1730
       1   0.0%  99.8%        1   0.0% ?? /usr/src/debug////////glibc-2.17-c758a686/string/../sysdeps/x86_64/multiarch/strcmp-sse42.S:134
       1   0.0%  99.9%        1   0.0% ?? /usr/src/debug////////glibc-2.17-c758a686/string/../sysdeps/x86_64/multiarch/strcmp-sse42.S:202
       1   0.0%  99.9%        1   0.0% ?? /usr/src/debug////////glibc-2.17-c758a686/string/../sysdeps/x86_64/multiarch/strcmp-sse42.S:1721
       1   0.0% 100.0%        1   0.0% SortedList_insert
       1   0.0% 100.0%        1   0.0% init_list_elements
       0   0.0% 100.0%     2565 100.0% ?? /usr/src/debug////////glibc-2.17-c758a686/misc/../sysdeps/unix/sysv/linux/x86_64/clone.S:111
       0   0.0% 100.0%        1   0.0% __libc_start_main
       0   0.0% 100.0%        1   0.0% _start
       0   0.0% 100.0%        1   0.0% main
       0   0.0% 100.0%     2565 100.0% start_thread
ROUTINE ====================== thread_start_routine in /u/cs/ugrad/stewart/111/proj2b/lab2_list.c
  2536   2565 Total samples (flat / cumulative)
     .      .   38: 
     .      .   39: long calc_elapsed_time(struct timespec start, struct timespec stop) {
     .      .   40:     return (stop.tv_sec - start.tv_sec) * 1000000000L + (stop.tv_nsec - start.tv_nsec);
     .      .   41: }
     .      .   42: 
---
     .      .   43: void * thread_start_routine(void * threadarg) {
     .      .   44:     struct thread_data * my_data = (struct thread_data * ) threadarg;
     .      .   45:     SortedListElement_t * arr = my_data->elem_arr;
     .      .   46:     struct timespec start, stop;
     .      .   47:     // Insert all elements into global list
     .      .   48:     for (int i = 0; i < num_iterations; i++) {
     .      .   49:         if (opt_sync && arg_sync != NULL) {
     .      .   50:             // Get lock
     .      .   51:             if ( * arg_sync == 'm') {
     .      .   52: 		if (clock_gettime(CLOCK_MONOTONIC, & start) == -1) {
     .      .   53: 		    fprintf(stderr, "Error retrieving time.\nclock_gettime: %s\n", strerror(errno));
     .      .   54: 		    exit(1);
     .      .   55: 		}
     .      .   56:                 if (pthread_mutex_lock( & lock) != 0) {
     .      .   57:                     fprintf(stderr, "Error locking mutex.\n");
     .      .   58:                     exit(1);
     .      .   59:                 }
     .      .   60:             } else if ( * arg_sync == 's') {
  1643   1643   61:                 while (__sync_lock_test_and_set( & spin_lock, 1)) {
     6      6   62:                     continue;
     .      .   63:                 }
     .      .   64:             }
     .      .   65: 	    if (clock_gettime(CLOCK_MONOTONIC, & stop) == -1) {
     .      .   66: 		fprintf(stderr, "Error retrieving time.\nclock_gettime: %s\n", strerror(errno));
     .      .   67: 		exit(1);
     .      .   68: 	    }
     .      .   69: 	    my_data->mutex_wait_time += calc_elapsed_time(start, stop);
     .      .   70:         }
     .      1   71:         SortedList_insert( & head, & arr[i]);
     .      .   72:         if (opt_sync && arg_sync != NULL) {
     .      .   73:             // Release lock
     .      .   74:             if ( * arg_sync == 'm') {
     .      .   75:                 if (pthread_mutex_unlock( & lock) != 0) {
     .      .   76:                     fprintf(stderr, "Error unlocking mutex.\n");
     .      .   77:                     exit(1);
     .      .   78:                 }
     .      .   79:             } else if ( * arg_sync == 's') {
     .      .   80:                 __sync_lock_release( & spin_lock);
     .      .   81:             }
     .      .   82:         }
     .      .   83:     }
     .      .   84:     // Check list length
     .      .   85:     if (opt_sync && arg_sync != NULL) {
     .      .   86:         // Get lock
     .      .   87:         if ( * arg_sync == 'm') {
     .      .   88: 	    if (clock_gettime(CLOCK_MONOTONIC, & start) == -1) {
     .      .   89: 		fprintf(stderr, "Error retrieving time.\nclock_gettime: %s\n", strerror(errno));
     .      .   90:                 exit(1);
     .      .   91:             }
     .      .   92:             if (pthread_mutex_lock( & lock) != 0) {
     .      .   93:                 fprintf(stderr, "Error locking mutex.\n");
     .      .   94:                 exit(1);
     .      .   95:             }
     .      .   96:         } else if ( * arg_sync == 's') {
     8      8   97:             while (__sync_lock_test_and_set( & spin_lock, 1)) {
     .      .   98:                 continue;
     .      .   99:             }
     .      .  100:         }
     .      .  101: 	if (clock_gettime(CLOCK_MONOTONIC, & stop) == -1) {
     .      .  102: 	    fprintf(stderr, "Error retrieving time.\nclock_gettime: %s\n", strerror(errno));
     .      .  103:             exit(1);
     .      .  104:         }
     .      .  105:         my_data->mutex_wait_time += calc_elapsed_time(start, stop);
     .      .  106:     }
     .      .  107:     int length = SortedList_length( & head);
     .      .  108:     if (opt_sync && arg_sync != NULL) {
     .      .  109:         // Release lock
     .      .  110:         if ( * arg_sync == 'm') {
     .      .  111:             if (pthread_mutex_unlock( & lock) != 0) {
     .      .  112:                 fprintf(stderr, "Error unlocking mutex.\n");
     .      .  113:                 exit(1);
     .      .  114:             }
     .      .  115:         } else if ( * arg_sync == 's') {
     .      .  116:             __sync_lock_release( & spin_lock);
     .      .  117:         }
     .      .  118:     }
     .      .  119:     if (length < num_iterations) {
     .      .  120:         fprintf(stderr, "Error inserting elements: got %d instead of %d.\n", length, num_iterations);
     .      .  121:         exit(2);
     .      .  122:     }
     .      .  123: 
     .      .  124:     // Look up and delete each of the keys previously inserted
     .      .  125:     for (int i = 0; i < num_iterations; i++) {
     .      .  126:         if (opt_sync && arg_sync != NULL) {
     .      .  127:             // Get lock
     .      .  128:             if ( * arg_sync == 'm') {
     .      .  129: 		if (clock_gettime(CLOCK_MONOTONIC, & start) == -1) {
     .      .  130:                     fprintf(stderr, "Error retrieving time.\nclock_gettime: %s\n", strerror(errno));
     .      .  131:                     exit(1);
     .      .  132:                 }
     .      .  133:                 if (pthread_mutex_lock( & lock) != 0) {
     .      .  134:                     fprintf(stderr, "Error locking mutex.\n");
     .      .  135:                     exit(1);
     .      .  136:                 }
     .      .  137:             } else if ( * arg_sync == 's') {
   877    877  138:                 while (__sync_lock_test_and_set( & spin_lock, 1)) {
     2      2  139:                     continue;
     .      .  140:                 }
     .      .  141:             }
     .      .  142: 	    if (clock_gettime(CLOCK_MONOTONIC, & stop) == -1) {
     .      .  143: 		fprintf(stderr, "Error retrieving time.\nclock_gettime: %s\n", strerror(errno));
     .      .  144: 		exit(1);
     .      .  145: 	    }
     .      .  146: 	    my_data->mutex_wait_time += calc_elapsed_time(start, stop);
     .      .  147:         }
     .     28  148:         SortedListElement_t * element = SortedList_lookup( & head, arr[i].key);
     .      .  149:         if (element == NULL) {
     .      .  150:             fprintf(stderr, "Error looking up element.\n");
     .      .  151:             exit(2);
     .      .  152:         }
     .      .  153:         if (SortedList_delete(element) != 0) {
     .      .  154:             fprintf(stderr, "Error deleting element.\n");
     .      .  155:             exit(2);
     .      .  156:         }
     .      .  157:         if (opt_sync && arg_sync != NULL) {
     .      .  158:             // Release lock
     .      .  159:             if ( * arg_sync == 'm') {
     .      .  160:                 if (pthread_mutex_unlock( & lock) != 0) {
     .      .  161:                     fprintf(stderr, "Error unlocking mutex.\n");
     .      .  162:                     exit(1);
     .      .  163:                 }
     .      .  164:             } else if ( * arg_sync == 's') {
     .      .  165:                 __sync_lock_release( & spin_lock);
     .      .  166:             }
     .      .  167:         }
     .      .  168:     }
     .      .  169:     return NULL;
     .      .  170: }
---
     .      .  171: 
     .      .  172: void init_list_elements(int num_elements) {
     .      .  173:     element_arr = malloc(sizeof(SortedListElement_t) * num_elements);
     .      .  174:     if (element_arr == NULL) {
     .      .  175:         fprintf(stderr, "Error allocating memory for elements.\n");
ROUTINE ====================== thread_start_routine in /u/cs/ugrad/stewart/111/proj2b/lab2_list.c
  2536   2565 Total samples (flat / cumulative)
     .      .   38: 
     .      .   39: long calc_elapsed_time(struct timespec start, struct timespec stop) {
     .      .   40:     return (stop.tv_sec - start.tv_sec) * 1000000000L + (stop.tv_nsec - start.tv_nsec);
     .      .   41: }
     .      .   42: 
---
     .      .   43: void * thread_start_routine(void * threadarg) {
     .      .   44:     struct thread_data * my_data = (struct thread_data * ) threadarg;
     .      .   45:     SortedListElement_t * arr = my_data->elem_arr;
     .      .   46:     struct timespec start, stop;
     .      .   47:     // Insert all elements into global list
     .      .   48:     for (int i = 0; i < num_iterations; i++) {
     .      .   49:         if (opt_sync && arg_sync != NULL) {
     .      .   50:             // Get lock
     .      .   51:             if ( * arg_sync == 'm') {
     .      .   52: 		if (clock_gettime(CLOCK_MONOTONIC, & start) == -1) {
     .      .   53: 		    fprintf(stderr, "Error retrieving time.\nclock_gettime: %s\n", strerror(errno));
     .      .   54: 		    exit(1);
     .      .   55: 		}
     .      .   56:                 if (pthread_mutex_lock( & lock) != 0) {
     .      .   57:                     fprintf(stderr, "Error locking mutex.\n");
     .      .   58:                     exit(1);
     .      .   59:                 }
     .      .   60:             } else if ( * arg_sync == 's') {
  1643   1643   61:                 while (__sync_lock_test_and_set( & spin_lock, 1)) {
     6      6   62:                     continue;
     .      .   63:                 }
     .      .   64:             }
     .      .   65: 	    if (clock_gettime(CLOCK_MONOTONIC, & stop) == -1) {
     .      .   66: 		fprintf(stderr, "Error retrieving time.\nclock_gettime: %s\n", strerror(errno));
     .      .   67: 		exit(1);
     .      .   68: 	    }
     .      .   69: 	    my_data->mutex_wait_time += calc_elapsed_time(start, stop);
     .      .   70:         }
     .      1   71:         SortedList_insert( & head, & arr[i]);
     .      .   72:         if (opt_sync && arg_sync != NULL) {
     .      .   73:             // Release lock
     .      .   74:             if ( * arg_sync == 'm') {
     .      .   75:                 if (pthread_mutex_unlock( & lock) != 0) {
     .      .   76:                     fprintf(stderr, "Error unlocking mutex.\n");
     .      .   77:                     exit(1);
     .      .   78:                 }
     .      .   79:             } else if ( * arg_sync == 's') {
     .      .   80:                 __sync_lock_release( & spin_lock);
     .      .   81:             }
     .      .   82:         }
     .      .   83:     }
     .      .   84:     // Check list length
     .      .   85:     if (opt_sync && arg_sync != NULL) {
     .      .   86:         // Get lock
     .      .   87:         if ( * arg_sync == 'm') {
     .      .   88: 	    if (clock_gettime(CLOCK_MONOTONIC, & start) == -1) {
     .      .   89: 		fprintf(stderr, "Error retrieving time.\nclock_gettime: %s\n", strerror(errno));
     .      .   90:                 exit(1);
     .      .   91:             }
     .      .   92:             if (pthread_mutex_lock( & lock) != 0) {
     .      .   93:                 fprintf(stderr, "Error locking mutex.\n");
     .      .   94:                 exit(1);
     .      .   95:             }
     .      .   96:         } else if ( * arg_sync == 's') {
     8      8   97:             while (__sync_lock_test_and_set( & spin_lock, 1)) {
     .      .   98:                 continue;
     .      .   99:             }
     .      .  100:         }
     .      .  101: 	if (clock_gettime(CLOCK_MONOTONIC, & stop) == -1) {
     .      .  102: 	    fprintf(stderr, "Error retrieving time.\nclock_gettime: %s\n", strerror(errno));
     .      .  103:             exit(1);
     .      .  104:         }
     .      .  105:         my_data->mutex_wait_time += calc_elapsed_time(start, stop);
     .      .  106:     }
     .      .  107:     int length = SortedList_length( & head);
     .      .  108:     if (opt_sync && arg_sync != NULL) {
     .      .  109:         // Release lock
     .      .  110:         if ( * arg_sync == 'm') {
     .      .  111:             if (pthread_mutex_unlock( & lock) != 0) {
     .      .  112:                 fprintf(stderr, "Error unlocking mutex.\n");
     .      .  113:                 exit(1);
     .      .  114:             }
     .      .  115:         } else if ( * arg_sync == 's') {
     .      .  116:             __sync_lock_release( & spin_lock);
     .      .  117:         }
     .      .  118:     }
     .      .  119:     if (length < num_iterations) {
     .      .  120:         fprintf(stderr, "Error inserting elements: got %d instead of %d.\n", length, num_iterations);
     .      .  121:         exit(2);
     .      .  122:     }
     .      .  123: 
     .      .  124:     // Look up and delete each of the keys previously inserted
     .      .  125:     for (int i = 0; i < num_iterations; i++) {
     .      .  126:         if (opt_sync && arg_sync != NULL) {
     .      .  127:             // Get lock
     .      .  128:             if ( * arg_sync == 'm') {
     .      .  129: 		if (clock_gettime(CLOCK_MONOTONIC, & start) == -1) {
     .      .  130:                     fprintf(stderr, "Error retrieving time.\nclock_gettime: %s\n", strerror(errno));
     .      .  131:                     exit(1);
     .      .  132:                 }
     .      .  133:                 if (pthread_mutex_lock( & lock) != 0) {
     .      .  134:                     fprintf(stderr, "Error locking mutex.\n");
     .      .  135:                     exit(1);
     .      .  136:                 }
     .      .  137:             } else if ( * arg_sync == 's') {
   877    877  138:                 while (__sync_lock_test_and_set( & spin_lock, 1)) {
     2      2  139:                     continue;
     .      .  140:                 }
     .      .  141:             }
     .      .  142: 	    if (clock_gettime(CLOCK_MONOTONIC, & stop) == -1) {
     .      .  143: 		fprintf(stderr, "Error retrieving time.\nclock_gettime: %s\n", strerror(errno));
     .      .  144: 		exit(1);
     .      .  145: 	    }
     .      .  146: 	    my_data->mutex_wait_time += calc_elapsed_time(start, stop);
     .      .  147:         }
     .     28  148:         SortedListElement_t * element = SortedList_lookup( & head, arr[i].key);
     .      .  149:         if (element == NULL) {
     .      .  150:             fprintf(stderr, "Error looking up element.\n");
     .      .  151:             exit(2);
     .      .  152:         }
     .      .  153:         if (SortedList_delete(element) != 0) {
     .      .  154:             fprintf(stderr, "Error deleting element.\n");
     .      .  155:             exit(2);
     .      .  156:         }
     .      .  157:         if (opt_sync && arg_sync != NULL) {
     .      .  158:             // Release lock
     .      .  159:             if ( * arg_sync == 'm') {
     .      .  160:                 if (pthread_mutex_unlock( & lock) != 0) {
     .      .  161:                     fprintf(stderr, "Error unlocking mutex.\n");
     .      .  162:                     exit(1);
     .      .  163:                 }
     .      .  164:             } else if ( * arg_sync == 's') {
     .      .  165:                 __sync_lock_release( & spin_lock);
     .      .  166:             }
     .      .  167:         }
     .      .  168:     }
     .      .  169:     return NULL;
     .      .  170: }
---
     .      .  171: 
     .      .  172: void init_list_elements(int num_elements) {
     .      .  173:     element_arr = malloc(sizeof(SortedListElement_t) * num_elements);
     .      .  174:     if (element_arr == NULL) {
     .      .  175:         fprintf(stderr, "Error allocating memory for elements.\n");
